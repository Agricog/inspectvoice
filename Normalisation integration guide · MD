# AI Style Normalisation — Frontend Integration Guide

## Files to ADD (drop in as-is)
```
src/types/normalisation.ts              → NEW
src/components/NormaliseButton.tsx       → NEW
src/components/NormalisationReviewPanel.tsx → NEW
src/components/NormalisationSettings.tsx → NEW
src/pages/NormalisationHistoryPage.tsx   → NEW
```

## Files to EDIT (merge instructions below)

---

### 1. App.tsx — Add route

**Add import** (with the other page imports at top):
```tsx
import NormalisationHistoryPage from '@pages/NormalisationHistoryPage';
```

**Add route** (inside the protected `<Route element={<AuthGate><Layout /></AuthGate>}>` block, after the Settings route):
```tsx
{/* Normalisation History */}
<Route path="/normalisation-history" element={<NormalisationHistoryPage />} />
```

---

### 2. SettingsPage.tsx — Add normalisation section

**Add import** (with other imports at top):
```tsx
import { NormalisationSettings } from '@components/NormalisationSettings';
```

**Add section** (after `<InspectionPreferences>` and before the non-admin message):

Find this block:
```tsx
{isManagerOrAdmin && org && (
  <>
    <OrganisationSection org={org} onSave={handleSaveOrg} />
    <InspectionPreferences org={org} onSave={handleSaveOrg} />
  </>
)}
```

Replace with:
```tsx
{isManagerOrAdmin && org && (
  <>
    <OrganisationSection org={org} onSave={handleSaveOrg} />
    <InspectionPreferences org={org} onSave={handleSaveOrg} />
    <NormalisationSettings org={org} onSave={handleSaveOrg} />
  </>
)}
```

That's it — one line added.

---

### 3. InspectionReview.tsx — Add batch normalise at sign-off

This is the most involved edit. The normalisation review panel sits between the
completeness check and the actual sign-off.

**Add imports** (at top with other imports):
```tsx
import { NormalisationReviewPanel } from '@components/NormalisationReviewPanel';
import { BatchNormaliseButton } from '@components/NormaliseButton';
import { NormaliseButton } from '@components/NormaliseButton';
import type { NormaliseResult } from '@/types/normalisation';
```

**Add state** (in the main component, with other state declarations):
```tsx
// ---- Normalisation ----
const [normResults, setNormResults] = useState<NormaliseResult[]>([]);
const [showNormReview, setShowNormReview] = useState(false);
```

**Add normalisation panel in the Inspector Summary section**.

Find the inspector summary textarea section:
```tsx
{/* ── Inspector Summary ── */}
<div className="iv-panel p-5 mb-4">
  <h2 className="text-base font-semibold iv-text mb-3 flex items-center gap-2">
    <FileText className="w-4 h-4 text-[#22C55E]" />
    Inspector Summary
  </h2>
  <textarea
    value={summary}
    ...
  />
  <p className="text-xs iv-muted mt-1 text-right">{summary.length}/5000</p>
</div>
```

Add the NormaliseButton after the character count:
```tsx
  <p className="text-xs iv-muted mt-1 text-right">{summary.length}/5000</p>

  {/* Per-field normalise button */}
  {summary.trim().length >= 10 && (
    <div className="mt-2">
      <NormaliseButton
        fieldName="inspector_summary"
        originalText={summary}
        inspectionId={inspectionId}
        onAccept={(text) => setSummary(text)}
      />
    </div>
  )}
</div>
```

**Modify the sign-off flow to include normalisation review**.

The current flow is:
  handleRequestSignOff → showCompletenessCheck → handleSignOff

The new flow adds a normalisation step:
  handleRequestSignOff → showCompletenessCheck → handleCompletenessPass
    → batch normalise → showNormReview (if changes) → handleNormComplete → handleSignOff

Add this handler (after the existing handleRequestSignOff):
```tsx
// ---- After completeness check passes, run batch normalisation ----
const handleCompletenessPass = useCallback(async () => {
  setShowCompletenessCheck(false);

  // Collect all normalisable fields from this inspection
  const fields = [];

  // Inspector summary
  if (summary.trim().length >= 10) {
    fields.push({
      fieldName: 'inspector_summary' as const,
      originalText: summary,
      inspectionId,
    });
  }

  // Per-item defect descriptions and remedial actions
  for (const item of items) {
    for (const defect of item.defects) {
      if (typeof defect === 'object' && defect.description?.length >= 10) {
        fields.push({
          fieldName: 'defect_description' as const,
          originalText: defect.description,
          inspectionId,
          inspectionItemId: item.id,
        });
      }
      if (typeof defect === 'object' && defect.remedial_action?.length >= 10) {
        fields.push({
          fieldName: 'remedial_action' as const,
          originalText: defect.remedial_action,
          inspectionId,
          inspectionItemId: item.id,
        });
      }
    }
  }

  if (fields.length === 0) {
    // No text to normalise — go straight to sign-off
    void handleSignOff();
    return;
  }

  // Try batch normalise — if org doesn't have it enabled, skip silently
  try {
    const { secureFetch } = await import('@hooks/useFetch');
    const response = await secureFetch<{
      success: boolean;
      data: { results: NormaliseResult[]; budgetRemaining: number };
    }>('/api/v1/normalise/batch', {
      method: 'POST',
      body: { fields: fields.map((f) => ({
        field_name: f.fieldName,
        original_text: f.originalText,
        inspection_id: f.inspectionId,
        inspection_item_id: f.inspectionItemId,
      }))},
    });

    const changed = response.data.results.filter((r) => !r.noChangesNeeded);
    if (changed.length > 0) {
      setNormResults(changed);
      setShowNormReview(true);
      return;
    }
  } catch {
    // Normalisation not enabled or failed — proceed silently
  }

  // No changes or normalisation unavailable
  void handleSignOff();
}, [summary, items, inspectionId, handleSignOff]);

// ---- After normalisation review completes ----
const handleNormComplete = useCallback((accepted: NormaliseResult[]) => {
  setShowNormReview(false);

  // Apply accepted text back to local state
  for (const result of accepted) {
    if (result.fieldName === 'inspector_summary') {
      setSummary(result.normalisedText);
    }
    // Defect text updates would need more sophisticated state management
    // (updating items array) — for v1, the accepted text is recorded in the
    // normalisation_log and applied when data syncs to server.
  }

  void handleSignOff();
}, [handleSignOff]);
```

**Update the CompletenessCheckModal onProceed** to call the new handler:

Change:
```tsx
<CompletenessCheckModal
  ...
  onProceed={() => void handleSignOff()}
  ...
/>
```

To:
```tsx
<CompletenessCheckModal
  ...
  onProceed={() => void handleCompletenessPass()}
  ...
/>
```

**Add the normalisation review panel** (after the CompletenessCheckModal, before the closing `</div>`):
```tsx
{/* ── Normalisation Review Panel ── */}
{showNormReview && normResults.length > 0 && (
  <div className="fixed inset-0 z-50 bg-black/60 flex items-center justify-center p-4">
    <div className="w-full max-w-2xl max-h-[90vh] overflow-y-auto">
      <NormalisationReviewPanel
        results={normResults}
        onComplete={handleNormComplete}
        onCancel={() => { setShowNormReview(false); void handleSignOff(); }}
      />
    </div>
  </div>
)}
```

---

## Summary of changes

| File | Change |
|------|--------|
| `src/types/normalisation.ts` | **NEW** — all normalisation types |
| `src/components/NormaliseButton.tsx` | **NEW** — per-field + batch buttons |
| `src/components/NormalisationReviewPanel.tsx` | **NEW** — sign-off review panel |
| `src/components/NormalisationSettings.tsx` | **NEW** — settings section |
| `src/pages/NormalisationHistoryPage.tsx` | **NEW** — manager history page |
| `src/App.tsx` | **EDIT** — add 1 import + 1 route |
| `src/pages/SettingsPage.tsx` | **EDIT** — add 1 import + 1 component line |
| `src/pages/InspectionReview.tsx` | **EDIT** — add imports, state, handlers, UI |

## Run migration FIRST
Run `migrations/007_normalisation.sql` in Neon SQL Editor before deploying frontend.

## Testing order
1. Settings → enable normalisation for your org
2. Start a test inspection → dictate some informal notes
3. In review, click "Normalise" on the summary field → verify diff appears
4. Sign off → verify batch normalisation panel appears
5. Check /normalisation-history → verify entries logged

# Feature 17: Manufacturer Recall Hooks — Integration Guide

## New Files to Commit (5 files)

| # | File | Destination |
|---|------|-------------|
| 1 | `010_manufacturer_recalls.sql` | `migrations/010_manufacturer_recalls.sql` |
| 2 | `recalls.ts` (backend) | `workers/src/routes/recalls.ts` |
| 3 | `recalls.ts` (types) | `src/types/recalls.ts` |
| 4 | `RecallAlertBanner.tsx` | `src/components/RecallAlertBanner.tsx` |
| 5 | `RecallsPage.tsx` | `src/pages/RecallsPage.tsx` |

---

## Existing File Changes (6 files)

### 1. `workers/src/index.ts`

**Add import** (after the magic links import block, ~line 68):

```typescript
// ── Feature 17: Manufacturer Recalls ──
import {
  listRecalls,
  getRecall,
  createRecall,
  updateRecall,
  updateRecallMatch,
  getActiveRecallAlerts,
  getAssetRecalls,
  rematchRecall,
} from './routes/recalls';
```

**Add routes** to the `ROUTES` array (after the magic links routes, before the closing `];`):

```typescript
  // ── Feature 17: Manufacturer Recalls ──
  ['GET',    '/api/v1/recalls/alerts', getActiveRecallAlerts],
  ['GET',    '/api/v1/recalls/:id', getRecall],
  ['POST',   '/api/v1/recalls/:id/rematch', rematchRecall],
  ['POST',   '/api/v1/recalls', createRecall],
  ['PUT',    '/api/v1/recalls/:id', updateRecall],
  ['GET',    '/api/v1/recalls', listRecalls],
  ['PUT',    '/api/v1/recalls/matches/:matchId', updateRecallMatch],
  ['GET',    '/api/v1/assets/:assetId/recalls', getAssetRecalls],
```

**IMPORTANT route order:** `/api/v1/recalls/alerts` MUST come before `/api/v1/recalls/:id` to avoid the router treating "alerts" as an `:id` param.

---

### 2. `src/App.tsx`

**Add import** (after the DefectLibraryPage import, ~line 43):

```typescript
// ── Feature 17: Manufacturer Recalls ──
import RecallsPage from '@pages/RecallsPage';
```

**Add route** (inside the protected routes block, after the defect-library route):

```tsx
            {/* ── Feature 17: Manufacturer Recalls ── */}
            <Route path="/recalls" element={<RecallsPage />} />
```

---

### 3. `src/components/Layout.tsx`

**Add import** (in the lucide-react import, add `Bell`):

Change:
```typescript
import {
  Shield,
  MapPin,
  ClipboardCheck,
  AlertTriangle,
  Settings,
  Menu,
  X,
  WifiOff,
  Wifi,
  Navigation,
  BarChart3,
  BookOpen,
} from 'lucide-react';
```

To:
```typescript
import {
  Shield,
  MapPin,
  ClipboardCheck,
  AlertTriangle,
  Settings,
  Menu,
  X,
  WifiOff,
  Wifi,
  Navigation,
  BarChart3,
  BookOpen,
  Bell,
} from 'lucide-react';
```

**Add nav item** (in NAV_ITEMS array, after the Library item, before Settings):

```typescript
  { to: '/recalls', label: 'Recalls', icon: <Bell className="w-4 h-4" /> },
```

So the full NAV_ITEMS becomes:
```typescript
const NAV_ITEMS: NavItem[] = [
  { to: '/sites', label: 'Sites', icon: <MapPin className="w-4 h-4" /> },
  { to: '/inspections', label: 'Inspections', icon: <ClipboardCheck className="w-4 h-4" /> },
  { to: '/defects', label: 'Defects', icon: <AlertTriangle className="w-4 h-4" /> },
  { to: '/route-planner', label: 'Route', icon: <Navigation className="w-4 h-4" /> },
  { to: '/inspector-performance', label: 'Performance', icon: <BarChart3 className="w-4 h-4" /> },
  { to: '/defect-library', label: 'Library', icon: <BookOpen className="w-4 h-4" /> },
  { to: '/recalls', label: 'Recalls', icon: <Bell className="w-4 h-4" /> },
  { to: '/settings', label: 'Settings', icon: <Settings className="w-4 h-4" /> },
];
```

---

### 4. `src/pages/ManagerDashboard.tsx`

**Add import** (after the PerformanceDashboardSection import, ~line 22):

```typescript
import { RecallAlertBanner } from '@components/RecallAlertBanner';
```

**Add banner** (in the dashboard content section, between the Hotlist and the two-column grid):

Find this block:
```tsx
            {/* HOTLIST — full width, prominent position */}
            <Hotlist defects={hotlist} />

            {/* Two-column grid: risk + upcoming */}
```

Change to:
```tsx
            {/* HOTLIST — full width, prominent position */}
            <Hotlist defects={hotlist} />

            {/* RECALL ALERTS — Feature 17 */}
            <RecallAlertBanner />

            {/* Two-column grid: risk + upcoming */}
```

---

### 5. `src/pages/AssetDetail.tsx`

**Add import** (after the existing imports, ~line 28):

```typescript
import { RecallAssetWarning } from '@components/RecallAlertBanner';
```

**Add warning** (in the main render, after the "No inspection yet banner" and before the Feature 2 history section):

Find this block:
```tsx
      {/* ── No inspection yet banner ── */}
      {!asset.last_inspection_date && !conditionSummary?.last_inspected && (
        ...
      )}

      {/* ══════════════════════════════════════════ */}
      {/* FEATURE 2: Longitudinal History Section   */}
```

Add between them:
```tsx
      {/* ── RECALL WARNING — Feature 17 ── */}
      <RecallAssetWarning assetId={asset.id} />
```

---

### 6. `src/types/index.ts`

**Add export** (after the existing exports):

```typescript
export * from './recalls';
```

Full file becomes:
```typescript
export * from './enums';
export * from './entities';
export * from './offline';
export * from './recalls';
```

---

## Database Deployment

Run `migrations/010_manufacturer_recalls.sql` in Neon SQL Editor.

Tables created:
- `manufacturer_recalls` — recall notices with severity, status, model patterns
- `recall_asset_matches` — matched assets with acknowledgement/action fields

Indexes: 9 total
RLS: 2 policies (tenant isolation)
Triggers: 2 (updated_at)
Constraints: 3 CHECK constraints + 1 UNIQUE (recall_id, asset_id)

---

## API Endpoints (Feature 17)

| Method | Path | Description | RBAC |
|--------|------|-------------|------|
| GET | `/api/v1/recalls` | List recalls (filterable by status) | All members |
| GET | `/api/v1/recalls/alerts` | Active recalls for dashboard banner | All members |
| GET | `/api/v1/recalls/:id` | Recall detail with matched assets | All members |
| POST | `/api/v1/recalls` | Create recall + run matching | Manager/Admin |
| PUT | `/api/v1/recalls/:id` | Update/resolve/dismiss recall | Manager/Admin |
| POST | `/api/v1/recalls/:id/rematch` | Re-run matching engine | Manager/Admin |
| PUT | `/api/v1/recalls/matches/:matchId` | Acknowledge/action a match | All members |
| GET | `/api/v1/assets/:assetId/recalls` | Recalls affecting specific asset | All members |

---

## Routing (added)

```
/recalls                    → Recall management (list, create, detail)
/recalls?id=:recallId       → Recall detail view (inline)
```

---

## Matching Engine Summary

Deterministic, explainable matching:
1. Filter by manufacturer (case-insensitive, trimmed) — exact or partial
2. If affected_models specified, match each pattern against asset model:
   - `ModelName` — exact match
   - `ModelName*` — prefix wildcard
   - `*suffix` — suffix wildcard
   - Contains match as fallback
3. Each match stores `match_reason` (full explanation) + `match_confidence` (exact/partial)
4. Re-running preserves already-actioned matches, only re-creates unacknowledged ones
# Feature 17 — Batch 2: Email Digest + Enhanced Filtering

## Files to Replace (3)

### 1. `workers/src/cron/summaryEmail.ts` — REPLACE ENTIRE FILE
**What changed:**
- Added 6th parallel query: active recalls with unacknowledged match counts
- New `RecallEmailItem` type imported from emailTemplates
- `AggregatedData` interface now includes `activeRecalls: RecallEmailItem[]`
- `SummaryEmailData` passed to template builder now includes `activeRecalls`
- `notification_log.summary_data` JSON now includes `active_recalls` count
- `filterBySite()` passes recalls through unfiltered (recalls are org-wide)
- No-activity check now includes `data.activeRecalls.length === 0`

### 2. `workers/src/services/emailTemplates.tsx` — REPLACE ENTIRE FILE
**What changed:**
- New exported type: `RecallEmailItem` (title, manufacturer, severity, matchedAssetCount, unacknowledgedCount)
- `SummaryEmailData` interface now includes `activeRecalls: RecallEmailItem[]`
- New `buildRecallSection()` function — severity-coded recall rows with pending review counts
- Recall section renders **before hotlist** (highest visibility for safety-critical items)
- New `COLORS.purple` / `COLORS.purpleBg` added (violet-600/50) — reserved for future use
- No-activity fallback now also checks `data.activeRecalls.length === 0`

### 3. `src/pages/RecallsPage.tsx` — REPLACE ENTIRE FILE
**What changed:**
- Added `Search` back to lucide imports (now used by manufacturer search input)
- Added state: `severityFilter` (RecallSeverity | null), `searchQuery` (string)
- Client-side filtering: severity dropdown + manufacturer/title text search
- Filter bar now wraps responsively (flex-col on mobile, flex-row on sm+)
- Empty state message adapts to active filters vs no-filter
- Removed unused `RecallStatus` local type alias
- All Batch 1 TS6133 fixes retained (unused imports removed, getAuthToken fixed)

## No Other File Changes
No new routes, no migration, no integration edits to existing files.
All 3 files are drop-in replacements.

## Email Recall Section Behaviour
- Recall section appears in **every** digest email (daily/weekly/monthly) when active recalls with matched assets exist
- Not gated by recipient section preferences — recalls are always shown for safety visibility
- Severity-sorted: critical first, then high, medium, advisory
- Shows unacknowledged count per recall with "pending review" tag
- Links to `/recalls` page for full management
- Border colour adapts: red if any critical recall present, amber otherwise

## Testing
1. Commit all 3 files
2. Deploy workers (`wrangler deploy`)
3. Test email cron manually: trigger the cron via Cloudflare dashboard → Triggers → Run Now
4. Verify recall section appears in email output when active recalls with matches exist
5. Test RecallsPage filters: severity buttons, manufacturer search, combined filters
6. Verify empty state adapts to "No recalls match your filters" when filtering
